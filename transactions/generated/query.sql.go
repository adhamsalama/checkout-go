// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package transactions

import (
	"context"
	"database/sql"
)

const getCumulativeBalancePerMonth = `-- name: GetCumulativeBalancePerMonth :many
WITH monthly_expenses AS (
    SELECT 
        CAST(strftime('%Y-%m', date) AS TEXT) AS year_month,  -- Format date as Year-Month
        SUM(price) AS monthly_balance
    FROM transactions
    WHERE user_id = ?
    GROUP BY year_month
)
SELECT 
    year_month,
    CAST(COALESCE(SUM(monthly_balance) OVER (ORDER BY year_month ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 0) AS REAL) AS cumulative_balance
FROM monthly_expenses
ORDER BY year_month
`

type GetCumulativeBalancePerMonthRow struct {
	YearMonth         string  `json:"year_month"`
	CumulativeBalance float64 `json:"cumulative_balance"`
}

func (q *Queries) GetCumulativeBalancePerMonth(ctx context.Context, userID int64) ([]GetCumulativeBalancePerMonthRow, error) {
	rows, err := q.db.QueryContext(ctx, getCumulativeBalancePerMonth, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCumulativeBalancePerMonthRow
	for rows.Next() {
		var i GetCumulativeBalancePerMonthRow
		if err := rows.Scan(&i.YearMonth, &i.CumulativeBalance); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getIncomeSpentPercentage = `-- name: GetIncomeSpentPercentage :many
WITH stats AS (
SELECT 
    CAST(strftime('%Y-%m', date) AS TEXT) AS month,         
    CAST(COALESCE(SUM(CASE WHEN price > 0 THEN price END), 0) AS REAL) AS total_income,  
    CAST(ABS(COALESCE(SUM(CASE WHEN price <= 0 THEN price END), 0)) AS REAL) AS total_spent,
    CAST(
        CASE 
            WHEN COALESCE(SUM(CASE WHEN price > 0 THEN price END), 0) = 0 
            THEN 0
            ELSE ROUND((ABS(SUM(CASE WHEN price <= 0 THEN price END)) * 100.0) 
                / SUM(CASE WHEN price > 0 THEN price END), 2)
        END 
    AS REAL) AS spent_percentage
FROM transactions
WHERE user_id = ?
GROUP BY month
ORDER BY month DESC
LIMIT 12
)
SELECT month, total_income, total_spent, spent_percentage FROM stats ORDER BY month ASC
`

type GetIncomeSpentPercentageRow struct {
	Month           string  `json:"month"`
	TotalIncome     float64 `json:"total_income"`
	TotalSpent      float64 `json:"total_spent"`
	SpentPercentage float64 `json:"spent_percentage"`
}

func (q *Queries) GetIncomeSpentPercentage(ctx context.Context, userID int64) ([]GetIncomeSpentPercentageRow, error) {
	rows, err := q.db.QueryContext(ctx, getIncomeSpentPercentage, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetIncomeSpentPercentageRow
	for rows.Next() {
		var i GetIncomeSpentPercentageRow
		if err := rows.Scan(
			&i.Month,
			&i.TotalIncome,
			&i.TotalSpent,
			&i.SpentPercentage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSumOfExpensesOfAMonth = `-- name: GetSumOfExpensesOfAMonth :one
SELECT SUM(price)
FROM transactions
WHERE user_id = ? AND price < 0 AND CAST(strftime('%Y', date) AS  INT) = ? AND CAST(strftime('%m', date) AS INT) = ?
`

type GetSumOfExpensesOfAMonthParams struct {
	UserID int64  `json:"user_id"`
	Date   string `json:"date"`
	Date_2 string `json:"date_2"`
}

func (q *Queries) GetSumOfExpensesOfAMonth(ctx context.Context, arg GetSumOfExpensesOfAMonthParams) (sql.NullFloat64, error) {
	row := q.db.QueryRowContext(ctx, getSumOfExpensesOfAMonth, arg.UserID, arg.Date, arg.Date_2)
	var sum sql.NullFloat64
	err := row.Scan(&sum)
	return sum, err
}
